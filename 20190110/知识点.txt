面试题：
代码块： 用{ }括起来的代码。
               局部代码块： 在方法中用{ }括起来。限定变量的生命周期。提高效率。（局部代码块中的内容只在局部范围内有效，用完就在在栈中消失）
              构造代码块：在成员位置用{} 括起来，把多个构造方法中相同的代码给抽出来，在每个构造执行前执行(先执行构造代码块中的内容，在执行构造方法中的内容)，每创创建一个对象都要执行一次。
             静态代码块： 在成员位置用 {}括起来的，用static 修饰的，对类中的数据进行初始化，对一些资源进行一次初始化

面试题： 静态代码块，构造代码块，构造方法的执行顺序？
            静态代码块 》 构造代码块 》 构造方法

总结：  静待代码块只执行一次
          构造代码块每次调用构造方法都执行一次

继承： 提高代码的复用性 继承关系是  is_ A 的关系，如狗是动物，狗的类就可以继承动物类（不要为了个别的方法而继承）

继承的特点：  A: Java只支持单继承， 不支持多继承
                     B： java支持多层继承
继承其实是体现一种关系：  xxx is a yyy一种

子父间的构造方法在执行时的关系：
              在执行子类的构造方法之前会执行父类的构造方法
              class Animal {
                     Aniamal ()  {System.out.println("This is a super class");}
                class  Dog extends Aniaml {
                      Dog () { System.out.println("This is a subclass");}
               当创建一个对象执行时：
                        Dog dog = new Dog();
                执行的结果时:  This is a super class
                                       This is a subclass   
                     }
                          }

注意： A： 在子类的构造方法中。默认第一条语句时super();
           B：在构造方法中，this()和super()这种用法只会有一个出现，并且都应该是第一条语句。

          super():放第一，是因为子类要访问父类的数据，所以父亲必须先被初始化。
		  this():放第一，是因为如果this()可以放后面，那么，我们对父亲的初始化就执行了多次。

面试题：
		继承有没有把构造方法给继承过来?
			构造方法是不被继承的。
		在执行子类的构造方法的时候，有没有创建父类的对象?
			没有。调用父类构造仅仅是对父亲进行了数据的初始化。
			创建对象，一般都是通过new去申请空间的。

	记住：任何类都直接或者间接的继承自Object类。

final:最终的意思。它可以修饰类，成员变量，成员方法。
	特点：
		它修饰的方法不能被重写。
		它修饰的成员变量是一个常量。
			数据类型 变量名 = 初始化值;
			常量修饰符 数据类型 常量名 = 初始化值;
		它修饰的类不能被继承。

问题：final定义的变量必须给值，那么在什么时候给值?
		A:在定义的时候就给值。一般都是这样用的。
		B:还有没有再其他的时候给赋值的情况
			有，在构造方法执行完毕之前赋值都可以。(面试)

final修饰基本类型变量：表示值不能改变。
	final修饰引用类型变量：表示地址值不能改变，而该对象的内容是可以发生改变的。

API中对应我们的类：
		字段摘要：成员变量
		构造方法摘要：构造方法
		方法摘要：成员方法

	Math类要掌握的内容：
		成员变量：
			自然对象底数：public static final double E
			圆周率：public static final double PI
		成员方法：
			随机数：public static double random()
			绝对值：public static int abs(int a)
			向上取整：public static double ceil(double a)
			向下取整：public static double floor(double a)
			最大值：public static int max(int a,int b)
			最小值：public static int min(int a,int b)
			次幂：public static double pow(double a,double b)
			四舍五入：public static int round(float a)
			正平方根：public static double sqrt(double a)

子父类间的成员方法关系：
		子类调用的时候，先用的是自己的，如果没有再使用父亲的。如果父亲没有，就使用父亲的父亲的...
		最后，如果没有，就报错。
		
	当子类中有和父类一模一样的方法的时候，子类使用的是自己的。
	这种现象被称为方法(覆盖，复写，)重写。

	方法重写：
		建议，子类和父类的模式一模一样。
		方法声明相同。

		方法名必须相同，参数列表必须相同。
		返回值类型可以不同：引用类型的时候，子类的返回值类型要是父类或者是父类返回类型的子类。

		推荐：修饰符，返回值类型，方法名，参数列表都相同。

	注意：
		A:子类的访问权限一定要大于等于父类。
		B:子类的返回值类型要小于等于父类的返回值类型。
		C:私有方法是不能被重写的。
		D:静态只能被静态方法重写。


继承的好处：
		A:提高了代码的复用性。
		B:让类与类产生了一个关系，这个关系是多态的前提。

	面向对象三大：
		封装
		继承
		多态

:一个类的创建过程(理解)
	Person p = new Person();

	A:把Person.class加载到内存
	B:在栈内存开辟空间存储p变量
	C:在堆内存为new Person()开辟空间
	D:对成员变量进行默认初始化
	E:对成员变量进行显示初始化
	F:通过构造方法对成员变量进行初始化
		(如果有构造代码块，通过它进行成员变量的初始化。)
	G:对象构造完毕，把地址值赋值给p变量

(7)面试题
		A:方法重写和方法重载的区别?方法重载能改变返回值类型吗?
                                     方法重写：在不同类中，方法声明相同。(方法名和参数列表)
		扩充：返回值类型可以小于等于父类返回值类型
		      权限修饰符要大于等于父类的权限修饰符

	方法重载：在同一个类，方法名相同，参数列表不同。

	重载可以改变返回值类型，因为它和返回值类型无关。

	重载：overload
	重写：override
		B:this和super的区别?以及他们的应用场景。
			this:代表当前类的引用对象。谁调用，代表谁。
			super:代表父类的存储空间标识。可以理解为父类引用对象。

			应用场景：
				成员变量
				构造方法
				成员方法

this and super的区别和应用场景？
this：代表当前类的一个引用对象。谁调用，它代表谁。
	super：代表的是父类的存储空间标识。可以理解为父类的引用对象。

	应用场景：
		成员变量：
			this.变量 使用当前类的成员变量
			super.变量 使用父类的成员变量
		构造方法：
			this(...) 使用当前类的构造方法
			super(...) 使用父类的构造方法
		成员方法：
			this.方法() 使用当前类的成员方法
			super.方法() 使用父类的成员方法

	构造方法问题：
		子类在实例化的时候，会首先调用父类的构造方法。
		在子类的构造方法中，默认有一个调用父类的无参构造方法。
		假如父类并没有提供无参构造方法。
		这个时候，代码就会报错，请问怎么解决?
			使用super(...)调用父类带参构造方法
			使用this(...)调用本类的其他构造方法

super仅仅是表示要先初始化父亲。



Math.round()出现的不是四舍五入?